/* eslint-disable quotes */
/* eslint-disable camelcase */
/* eslint-disable max-len */
// Import dependencies
const settings = require("../../settings.json");

const stripe = require("stripe")(settings.stripe.mode === "sandbox" ? settings.stripe.sandbox.private_key : settings.stripe.live.private_key);
import { bookshelf } from "~/Server/database/db";
import fs            from "fs";

// Import Models
import HistoryPaymentModel from "~/Server/database/models/providers/history_payment";

// Import others controllers
import UserController         from "~/Server/controllers/users/user_controller";
import { disableAllProducts } from "~/Server/controllers/products/provider_has_product_controller";

// Import Services
import { sendMailSubscription, sentMailPaymentsNotificacion } from "~/Server/services/emais/subscription_email";


async function getClientSecret(coupon = undefined) {
	let customer;
	if (coupon) {
		customer = await stripe.customers.create({
			coupon : coupon.code,
		});
	} else {
		customer = await stripe.customers.create();
	}
	const { client_secret } = await stripe.setupIntents.create({
		customer : customer.id,
	});
	return { clientSecret : client_secret };
}

async function validateCoupon(couponId) {
	try {
		const coupon = await stripe.coupons.retrieve(couponId);
		if (coupon.valid) {
			return {
				"message"            : "success",
				"label"              : "coupon is valid",
				"percent_off"        : coupon.percent_off,
				"amount_off"         : coupon.amount_off ? coupon.amount_off / 100 : null,
				"created"            : coupon.created,
				"duration_in_months" : coupon.duration_in_months,
			};
		} else {
			throw {
				status  : 500,
				label   : "COUPON NOT FOUND",
				message : 'Coupon does´nt exist',
			};
		}
	} catch (error) {
		throw {
			error   : error,
			status  : 500,
			label   : "ERROR IN STRIPE PROCESS COUPON",
			message : 'Coupon does´nt exist',
		};
	}
}

/**
 * Inserts a new Paymen History register into the database.
 *
 * @author  Cesar A. Herrera de la T.
 * @version 0.10.0
 * @since   0.10.0
 * @param {{
 *     provider_id     : number,
 *     subscription_id : number,
 *     price           : number,
 *     type            :
 * }} body - Constains the necesary information to create the new register.
 * @return {Promise.<number, Error>} Returns a Promise which in case of success is fullfilled with the
 *                                   new record's database ID, otherwise rejects with some error.
*/
async function addPaymentHistory(body, transacting = undefined) {
	async function doWork(t) {
		const attributes = {
			provider_id     : body.provider_id || undefined,
			subscription_id : body.subscription_id,
			price           : body.price,
			type            : body.type,
			payment_token   : body.payment_token,
			status          : body.status || undefined,
			payment_status  : body.payment_status || undefined,
		};

		const options = {
			transacting : t,
		};

		return await new HistoryPaymentModel().save(attributes, options);
	}

	return transacting
		? doWork(transacting)
		: bookshelf.transaction(doWork);
}

const generateResponse = async (intent) => {
	// Generate a response based on the intent's status
	switch (intent.status) {
	  case "requires_action":
	  case "requires_source_action":
		// Card requires authentication
			return {
				succes         : false,
				requiresAction : true,
				clientSecret   : intent.client_secret,
			};
	  case "requires_payment_method":
	  case "requires_source":
		// Card was not properly authenticated, suggest a new payment method
			return {
				success : false,
				error   : "Your card was denied, please provide a new payment method",
			};
	  case "succeeded":
		// Payment is complete, authentication not required
		// To cancel the payment after capture you will need to issue a Refund (https://stripe.com/docs/api/refunds)
			return {
				success      : true,
				clientSecret : intent.client_secret,
				paymentId    : intent.id,
			};
	}
};

async function pay(body, transacting = undefined) {
	const doWork = async (t) => {
		let userResponse;
		try {
			userResponse  = await UserController.register(body, t);
			// Retrive Payment Method Object from stripe SDK, using paymentMethodId generated by stripe in FRONTEND.
			const paymentMethod = await stripe.paymentMethods.retrieve(body.provider.subscription.paymentMethod);
			let amount = (body.provider.subscription.price);
			if (body.provider.subscription.coupon) {
				if (body.provider.subscription.coupon.percent_off) {
					const discount = (body.provider.subscription.price * body.provider.subscription.coupon.percent_off / 100);
					amount = (body.provider.subscription.price - discount );
				} else {
					const discount = (body.provider.subscription.coupon.amount_off);
					if (discount > body.provider.subscription.price) {
						amount = 1;
					} else {
						amount = (body.provider.subscription.price - discount );
					}
				}
			}
			// Create and confirm a PaymentIntent with the order amount, currency, customer and PaymentMethod ID
			const paymentIntent = await stripe.paymentIntents.create({
				amount         : amount * 100,
				currency       : "mxn",
				payment_method : paymentMethod.id,
				customer       : paymentMethod.customer,
				off_session    : true,
				confirm        : true,
			});

			const paymentHistory = {
				subscription_id : body.provider.subscription.subscription_id,
				price           : amount,
				type            : body.provider.subscription.type,
				payment_token   : body.provider.subscription.paymentMethod,
				provider_id     : userResponse.profile_id,
				payment_status  : "PAID_OUT",
			};

			const { success } = await generateResponse(paymentIntent);
			if ( success ) {
				await addPaymentHistory(paymentHistory, t);
				const htmlTemplateNewSubscription = await makeTemplateNewSubscrition({
					first_name : body.provider.first_name,
					last_name  : body.provider.last_name,
				}, "SUCCESS");

				sendMailSubscription({
					html    : htmlTemplateNewSubscription,
					to      : body.provider.store_email,
					subject : "Membresia Zoko.",
				});
				return { message : "success", label : "payment done", payload : userResponse };
			} else {
				paymentHistory.status = "INACTIVE";
				await addPaymentHistory(paymentHistory, t);
				return { message : "success", label : "pago no recibido, cuenta generada inactiva", payload : userResponse };
			}
		} catch (error) {
			if (error.type && error.type == "StripeCardError") {
				const paymentHistory = {
					subscription_id : body.provider.subscription.subscription_id,
					price           : body.provider.subscription.price,
					type            : body.provider.subscription.type,
					payment_token   : body.provider.subscription.paymentMethod,
					provider_id     : userResponse.profile_id,
					status          : "INACTIVE",
					payment_status  : "WITHOUT_PAYING",
				};
				await addPaymentHistory(paymentHistory, t);
				return {
					message : "success", label : "pago no recibido, cuenta generada inactiva",
				};
			} else {
				throw { error };
			}
		}
	};

	return transacting
		? doWork(transacting)
		: bookshelf.transaction(doWork);
}

const PaySubscription = async ({ token, amount }) => {
	const paymentMethod = await stripe.paymentMethods.retrieve(token);
	const customer = await stripe.customers.retrieve(paymentMethod.customer);
	if (customer.discount.coupon) {
		if (customer.discount.coupon.percent_off) {
			const discount = (amount * customer.discount.coupon.percent_off / 100);
			amount = (amount - discount ) * 100;
		} else {
			const discount = customer.discount.coupon.amount_off / 100;
			if (amount < discount ) {
				amount = 1 * 100;
			} else {
				amount = (amount - discount ) * 100;
			}
		}
	}

	const paymentIntent = await stripe.paymentIntents.create({
		amount         : amount,
		currency       : "mxn",
		payment_method : token,
		customer       : paymentMethod.customer,
		off_session    : true,
		confirm        : true,
	});

	const { success, paymentId } = await generateResponse(paymentIntent);

	return { status : success, paymentId };
};

const makeTemplatePaymentSubscription = async (provider, status) => {
	let html = fs.readFileSync("src/Server/views/notification_message.html", "utf8");

	if (status === "SUCCESS") {
		html = html.replace("*LABEL_STATUS*", "Tu subscripción ha sido renovada.");
		html = html.replace("*STATUS*", "PAGO EXITOSO");
		html = html.replace("*MESSAGE*", `Tu membresia <strong>${provider.subscription}</strong> ha sido renovada, sigue disfruntando de los beneficios de tu subscripción`);
	} else {
		html = html.replace("*LABEL_STATUS*", "Tu subscripción ha sido cancelada.");
		html = html.replace("*STATUS*", "Lamentamos que te vayas");
		html = html.replace("*MESSAGE*", `Lamentablemente, no pudimos resolver el problema con tu pago y tu membresía ha sido cancelada. <br> Obviamente, nos gustaría que regresaras. Lo único que tienes que hacer es reiniciar tu membresía.`);
	}

	html = html.replace("*USER_NAME*", `${provider.first_name} ${provider.last_name}`);

	return html;
};

const makeTemplateNewSubscrition = async (provider, status) => {
	let html = fs.readFileSync("src/Server/views/notification_message.html", "utf8");

	html = html.replace("*LABEL_STATUS*", "Haz adquirido una membresia en Zoko.");
	html = html.replace("*STATUS*", "PAGO EXITOSO");
	html = html.replace("*MESSAGE*", "El pago de tu membresia en zoko ha sido exitoso, para mas detalles visita nuestra pagina www.zoko.mx");

	html = html.replace("*USER_NAME*", `${provider.first_name} ${provider.last_name}`);

	return html;
};

const makeTemplatePaymentsNotification = async (payments) => {
	let html         = fs.readFileSync("src/Server/views/notification_message.html", "utf8");
	let paymentsHtml = "<br><ul>*PAYMENT_IDS*</ul>";
	let paymentIds;

	for (const paymentId of payments) {
		paymentIds += `<li><strong>${paymentId}</strong></li>`;
	}

	paymentsHtml = paymentsHtml.replace("*PAYMENT_IDS*", paymentIds);

	html = html.replace("*LABEL_STATUS*", "Se han registrado pagos de membresias, verifica la información.");
	html = html.replace("*STATUS*", "Alerta de pagos");
	html = html.replace("*USER_NAME*", `${settings.admin.employeeInfo.first_name} ${settings.admin.employeeInfo.last_name}`);
	html = html.replace("*MESSAGE*", `Se han registrado los siguientes pagos en stripe. ${paymentsHtml}`);

	return html;
};

const renewalSuscriptions = async (transacting) => {
	async function doWork(t) {
		try {
			const updateOptions = {
				transacting : t,
				method      : "update",
				patch       : true,
			};

			const options = {
				transacting : t,
				withRelated : [ "subscription", "new_subscription", "provider" ],
			};

			const payments = [];
			const date     = new Date(Date.now());

			date.setDate(date.getDate() - 30);
			const month = date.getUTCMonth() + 1; //months from 1-12
			const day   = date.getUTCDate();
			const year  = date.getUTCFullYear();

			const dateStart = `${year}-${month}-${day} 00:00:00`;
			const dateEnd   = `${year}-${month}-${day} 23:59:59`;

			const historyPaymentsCollection = await HistoryPaymentModel.query(function(builder) {
				builder
					.columns("history_payment.*")
					.where("payment_status", "PAID_OUT")
					.where("status", "ACTIVE")
					.where("created_at", ">=", dateStart)
					.where("created_at", "<=", dateEnd);
			}).fetchAll(options);
			// return { dateStart, dateEnd };
			// return historyPaymentsCollection.models;
			for (const historyPaymentModel of historyPaymentsCollection.models) {
				const attributes = {
					provider_id   : historyPaymentModel.attributes.provider_id,
					type          : historyPaymentModel.attributes.type,
					payment_token : historyPaymentModel.attributes.payment_token,
				};
				if (historyPaymentModel.attributes.status === "INACTIVE") {
					await disableAllProducts(historyPaymentModel.attributes.provider_id, t);
				}
				else if (historyPaymentModel.attributes.status === "ACTIVE") {
					await historyPaymentModel.save({ status : "INACTIVE" }, updateOptions);
					const provider = historyPaymentModel.related("provider").attributes;
					//Cuando cambio de suscripción
					if (historyPaymentModel.attributes.new_subscription_id) {
						const newSubscription      = historyPaymentModel.related("new_subscription").attributes;
						attributes.price           = newSubscription.price;
						attributes.subscription_id = newSubscription.id;
						provider.subscription      = newSubscription.name;

						if (newSubscription.price < historyPaymentModel.attributes.price) {
							await disableAllProducts(historyPaymentModel.attributes.provider_id, t); // Desabilitamos los productos ya que es una membresia menor
						}
					} else {
						//Cuando es la misma suscripción
						const subscription         = historyPaymentModel.related("subscription").attributes;
						attributes.subscription_id = historyPaymentModel.attributes.subscription_id;
						attributes.price           = historyPaymentModel.attributes.price;
						provider.subscription      = subscription.name;
					}
					let paymentResponse;
					let paymentStatus;
					try {
						// Ejecutamos el pago con la funcion de pagos
						paymentResponse = await PaySubscription({
							amount : historyPaymentModel.related('subscription').attributes.price,
							token  : historyPaymentModel.attributes.payment_token,
						});
					} catch (error) {
						attributes.status         = "INACTIVE";
						attributes.payment_status = "WITHOUT_PAYING";
						await disableAllProducts(historyPaymentModel.attributes.provider_id, t); // Desabilitamos los productos ya que se cancelara la memebresia
						paymentStatus = "ERROR";
					}

					if (paymentResponse && !paymentResponse.status) {// Aqui es el caso cuando el pago no se ejecuta corretamente
						attributes.status         = "INACTIVE";
						attributes.payment_status = "WITHOUT_PAYING";
						await disableAllProducts(historyPaymentModel.attributes.provider_id, t); // Desabilitamos los productos ya que se cancelara la memebresia
						paymentStatus = "ERROR";
					} else if (paymentResponse) {
						payments.push(paymentResponse.paymentId);
						attributes.payment_status = "PAID_OUT";
						paymentStatus = "SUCCESS";
					}

					const htmlTemplateRenewalSubscription = await makeTemplatePaymentSubscription(provider, paymentStatus);

					sendMailSubscription({
						html    : htmlTemplateRenewalSubscription,
						to      : provider.store_email,
						subject : `Tu membresia de Zoko ha sido ${paymentStatus === "SUCCESS" ? "renovada" : "cancelada"}`,
					});

					await addPaymentHistory(attributes, t);
				}
				else {
					await historyPaymentModel.save({ status : "INACTIVE" }, updateOptions);
					await disableAllProducts(historyPaymentModel.attributes.provider_id, t);
				}
			}

			if (payments.length > 0) {
				const htmlTemplate = await makeTemplatePaymentsNotification(payments);
				sentMailPaymentsNotificacion({
					html    : htmlTemplate,
					to      : settings.admin.email,
					subject : `Notificación de pagos en Zoko`,
				});
			}
			return payments;
		} catch (error) {
			throw error && error.status && error.label ? error : {
				status  : 500,
				label   : "DATABASE_ERROR",
				message : "There was a problem with the database",
				error   : error,
			};
		}
	}

	return transacting
		? doWork(transacting)
		: bookshelf.transaction(doWork);
};

const changeSubscription = async function(body, transacting) {
	async function doWork(t) {
		const attributes = {
			new_subscription_id : body.new_subscription_id,
		};

		const options = {
			transacting : t,
			method      : "update",
			patch       : true,
		};

		const historyPaymentModel = await HistoryPaymentModel.query(function(builder) {
			builder
				.where("provider_id", body.provider_id)
				.where("status", "ACTIVE");
		}).fetch(options);

		if (!historyPaymentModel) {
			throw {
				status  : 409,
				label   : "NOT_FOUND",
				message : `Requested 'suscription' with ID [${ body.new_subscription_id }] was not found`,
				info    : { attributes },
			};
		}

		await historyPaymentModel.save(attributes, options);

		return { id : historyPaymentModel.id };
	}

	return transacting
		? doWork(transacting)
		: bookshelf.transaction(doWork);
};

const cancelSubscription = async function(body, transacting) {
	async function doWork(t) {
		const attributes = {
			status : "SUSPENDED",
		};

		const options = {
			transacting : t,
			method      : "update",
			patch       : true,
		};

		const historyPaymentModel = await HistoryPaymentModel.query(function(builder) {
			builder
				.where("provider_id", body.provider_id)
				.where("status", "ACTIVE");
		}).fetch(options);

		if (!historyPaymentModel) {
			throw {
				status  : 409,
				label   : "NOT_FOUND",
				message : `Requested 'suscription' was not found`,
				info    : { attributes },
			};
		}

		await historyPaymentModel.save(attributes, options);

		return { id : historyPaymentModel.id };
	}

	return transacting
		? doWork(transacting)
		: bookshelf.transaction(doWork);
};

module.exports = {
	pay,
	getClientSecret,
	renewalSuscriptions,
	changeSubscription,
	cancelSubscription,
	validateCoupon,
};
